// Custom hook for Supabase initialization
const useSupabase = () => {
  const [supabase, setSupabase] = useState<SupabaseClient | null>(null);
  const [connectionError, setConnectionError] = useState<string | null>(null);

  useEffect(() => {
    // Get environment variables
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || '';
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || '';

    // Log configuration status
    console.log('Supabase URL defined:', !!supabaseUrl, supabaseUrl ? supabaseUrl.substring(0, 10) + '...' : 'undefined');
    console.log('Supabase Key defined:', !!supabaseKey, supabaseKey ? `${supabaseKey.substring(0, 5)}...${supabaseKey.substring(supabaseKey.length - 5)}` : 'undefined');

    // Check for missing config
    if (!supabaseUrl || !supabaseKey) {
      setConnectionError('Supabase configuration is incomplete. Please check your environment variables.');
      return;
    }

    // Initialize Supabase client
    try {
      const client = createClient(supabaseUrl, supabaseKey, {
        auth: { 
          persistSession: true,
          autoRefreshToken: true
        }
      });
      setSupabase(client);
      console.log('Supabase client initialized successfully');
    } catch (error: any) {
      console.error('Failed to initialize Supabase client:', error);
      setConnectionError(`Failed to initialize Supabase client: ${error.message || 'Unknown error'}`);
    }
  }, []);

  // Function to check connection
  const checkConnection = useCallback(async (): Promise<boolean> => {
    if (!supabase) {
      setConnectionError('Supabase client is not initialized. Check your environment variables.');
      return false;
    }
    
    try {
      console.log('Testing Supabase connection...');
      const { error } = await supabase.from('level10_meetings').select('count').limit(1);
      
      if (error) {
        if (error.message?.includes('relation') && error.message?.includes('does not exist')) {
          console.log('Database is accessible but tables are not set up:', error.message);
          setConnectionError('Database is accessible, but required tables do not exist. Please run the setup SQL script.');
        } else {
          console.error('Database connection test failed:', error);
          setConnectionError(`Database connection failed: ${error.message}`);
        }
        return false;
      } else {
        console.log('Database connection test successful - skipping write permission test for now');
        setConnectionError(null);
        return true;
      }
    } catch (error: any) {
      console.error('Failed to check database connection:', error);
      setConnectionError(`Failed to connect to database: ${error.message || 'Unknown error'}`);
      return false;
    }
  }, [supabase]);

  // Function to set up database tables
  const setupDatabase = useCallback(async (): Promise<boolean> => {
    if (!supabase) return false;
    
    try {
      const setupSQL = `
        -- Level 10 Meetings table
        CREATE TABLE IF NOT EXISTS level10_meetings (
          id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
          meeting_date TIMESTAMPTZ,
          week_start_date DATE,
          attendees TEXT,
          safety_message TEXT,
          encore_values TEXT,
          closing_deals TEXT,
          bidding_deals TEXT,
          hot_properties TEXT,
          termination_changes TEXT,
          created_at TIMESTAMPTZ DEFAULT NOW(),
          updated_at TIMESTAMPTZ DEFAULT NOW()
        );
        -- Yearly Goals table
        CREATE TABLE IF NOT EXISTS yearly_goals (
          id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
          year INT,
          region TEXT DEFAULT 'Las Vegas',
          revenue_target NUMERIC,
          revenue_description TEXT,
          retention_goal NUMERIC,
          retention_description TEXT,
          current_revenue NUMERIC,
          current_retention NUMERIC,
          created_at TIMESTAMPTZ DEFAULT NOW(),
          updated_at TIMESTAMPTZ DEFAULT NOW()
        );
        -- Issues List table
        CREATE TABLE IF NOT EXISTS issues_list (
          id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
          issue_text TEXT,
          is_completed BOOLEAN DEFAULT FALSE,
          assigned_to TEXT,
          due_date DATE,
          week_start_date DATE,
          created_at TIMESTAMPTZ DEFAULT NOW(),
          updated_at TIMESTAMPTZ DEFAULT NOW()
        );
        -- Quarterly Rocks table
        CREATE TABLE IF NOT EXISTS quarterly_rocks (
          id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
          title TEXT,
          category TEXT,
          assigned_to TEXT,
          current_groups TEXT,
          action_items TEXT,
          current_status TEXT,
          updates_notes TEXT,
          event_details JSONB,
          week_start_date DATE,
          created_at TIMESTAMPTZ DEFAULT NOW(),
          updated_at TIMESTAMPTZ DEFAULT NOW()
        );
        -- Meeting Guidelines table
        CREATE TABLE IF NOT EXISTS meeting_guidelines (
          id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
          guideline_text TEXT,
          category TEXT,
          sort_order INT,
          week_start_date DATE,
          created_at TIMESTAMPTZ DEFAULT NOW(),
          updated_at TIMESTAMPTZ DEFAULT NOW()
        );
        -- Objection Handling table
        CREATE TABLE IF NOT EXISTS objection_handling (
          id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
          objection TEXT,
          rebuttal TEXT,
          things_to_say TEXT,
          things_not_to_say TEXT,
          created_at TIMESTAMPTZ DEFAULT NOW(),
          updated_at TIMESTAMPTZ DEFAULT NOW()
        );
        -- Quick Tips table
        CREATE TABLE IF NOT EXISTS quick_tips (
          id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
          category TEXT,
          tip_text TEXT,
          created_at TIMESTAMPTZ DEFAULT NOW(),
          updated_at TIMESTAMPTZ DEFAULT NOW()
        );
        -- Association Memberships table
        CREATE TABLE IF NOT EXISTS association_memberships (
          id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
          sales_rep TEXT,
          groups TEXT,
          committees TEXT,
          meeting_schedule TEXT,
          meetings_attended INT DEFAULT 0,
          total_meetings INT DEFAULT 0,
          week_start_date DATE,
          created_at TIMESTAMPTZ DEFAULT NOW(),
          updated_at TIMESTAMPTZ DEFAULT NOW()
        );
        -- Targets table
        CREATE TABLE IF NOT EXISTS targets (
          id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
          contact_name TEXT,
          contact_title TEXT,
          contact_email TEXT,
          company TEXT,
          properties TEXT,
          sales_rep TEXT,
          sales_rep_name TEXT,
          notes TEXT,
          status TEXT DEFAULT 'active',
          projected_value TEXT,
          created_at TIMESTAMPTZ DEFAULT NOW(),
          updated_at TIMESTAMPTZ DEFAULT NOW()
        );

        -- Add row level security policy for public access
        ALTER TABLE level10_meetings ENABLE ROW LEVEL SECURITY;
        ALTER TABLE yearly_goals ENABLE ROW LEVEL SECURITY;
        ALTER TABLE issues_list ENABLE ROW LEVEL SECURITY;
        ALTER TABLE quarterly_rocks ENABLE ROW LEVEL SECURITY;
        ALTER TABLE meeting_guidelines ENABLE ROW LEVEL SECURITY;
        ALTER TABLE objection_handling ENABLE ROW LEVEL SECURITY;
        ALTER TABLE quick_tips ENABLE ROW LEVEL SECURITY;
        ALTER TABLE association_memberships ENABLE ROW LEVEL SECURITY;
        ALTER TABLE targets ENABLE ROW LEVEL SECURITY;

        -- Create permissive policy for all tables
        DO $$
        DECLARE
          t text;
        BEGIN
          FOR t IN 
            SELECT table_name 
            FROM information_schema.tables 
            WHERE table_schema = 'public' 
              AND table_name IN (
                'level10_meetings', 'yearly_goals', 'issues_list', 
                'quarterly_rocks', 'meeting_guidelines', 'objection_handling', 
                'quick_tips', 'association_memberships', 'targets'
              )
          LOOP
            EXECUTE format('DROP POLICY IF EXISTS policy_all ON %I', t);
            EXECUTE format('CREATE POLICY policy_all ON %I USING (true) WITH CHECK (true)', t);
          END LOOP;
        END;
        $$;
      `;
      
      const { error } = await supabase.rpc('exec_sql', { sql: setupSQL });
      
      if (error) {
        console.error('Error setting up database tables:', error);
        if (error.message?.includes('function') && error.message?.includes('does not exist')) {
          throw new Error('The "exec_sql" RPC function does not exist. Please contact your Supabase administrator to enable it or create tables manually.');
        }
        throw error;
      }
      
      console.log('Database tables created successfully!');
      setConnectionError(null);
      return true;
    } catch (error: any) {
      console.error('Failed to set up database:', error);
      setConnectionError(`Failed to set up database: ${error.message || 'Unknown error'}`);
      return false;
    }
  }, [supabase]);

  return { supabase, connectionError, setConnectionError, checkConnection, setupDatabase };
};

// ========================
// UI Components
// ========================

// Enhanced section header component
interface SectionHeaderProps {
  title: string;
}

const SectionHeader = ({ title }: SectionHeaderProps) => (
  <div className="mb-6">
    <h3 className="text-lg font-semibold text-gray-800">{title}</h3>
    <div className="h-1 w-20 bg-blue-600 mt-2 rounded-full"></div>
  </div>
);

// Enhanced form field component
interface FormFieldProps {
  label: string;
  name: string;
  value: string;
  onChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
  placeholder: string;
  isTextArea?: boolean;
}

const FormField = ({ 
  label, 
  name, 
  value, 
  onChange, 
  placeholder, 
  isTextArea = false 
}: FormFieldProps) => (
  <div className="space-y-2 transition-all duration-200 hover:shadow-sm">
    <label className="block text-sm font-medium text-gray-700">
      {label}
    </label>
    {isTextArea ? (
      <textarea
        name={name}
        value={value}
        onChange={onChange}
        placeholder={placeholder}
        className="w-full bg-white border border-gray-200 rounded-lg p-3 transition-colors duration-200 focus:border-blue-500 focus:ring-2 focus:ring-blue-200 min-h-[120px]"
      />
    ) : (
      <Input
        name={name}
        value={value}
        onChange={onChange}
        placeholder={placeholder}
        className="w-full bg-white border border-gray-200 rounded-lg p-3 transition-colors duration-200 focus:border-blue-500 focus:ring-2 focus:ring-blue-200"
      />
    )}
  </div>
);

// Error card component for displaying detailed errors
interface ErrorCardProps {
  title: string;
  error: string | { message?: string; details?: any } | null;
  onRetry?: () => void;
}

const ErrorCard = ({ 
  title, 
  error, 
  onRetry 
}: ErrorCardProps) => (
  <div className="bg-white rounded-xl p-4 shadow-md border border-red-200 mb-4">
    <div className="flex items-center text-red-600 mb-3">
      <AlertTriangle className="h-5 w-5 mr-2" />
      <h2 className="text-lg font-semibold">{title}</h2>
    </div>
    <p className="text-sm text-gray-700 mb-3">
      {typeof error === 'string' ? error : (error?.message || 'An unknown error occurred')}
    </p>
    {error && typeof error !== 'string' && error.details && (
      <pre className="bg-gray-50 p-2 rounded text-xs overflow-x-auto mb-3">
        {JSON.stringify(error.details, null, 2)}
      </pre>
    )}
    {onRetry && (
      <Button 
        size="sm" 
        className="bg-red-600 hover:bg-red-700 text-white" 
        onClick={onRetry}
      >
        <RefreshCw className="w-4 h-4 mr-2" /> Retry
      </Button>
    )}
  </div>
);

// Loading indicator component
interface LoadingIndicatorProps {
  message?: string;
}

const LoadingIndicator = ({ message = "Loading..." }: LoadingIndicatorProps) => (
  <div className="flex justify-center items-center py-8">
    <Loader2 className="h-6 w-6 animate-spin text-blue-600 mr-3" />
    <span className="text-gray-600">{message}</span>
  </div>
);

// Save button with status indicator
interface SaveButtonProps {
  onClick: () => void;
  status: 'idle' | 'saving' | 'success' | 'error';
  disabled?: boolean;
}

const SaveButton = ({ onClick, status, disabled }: SaveButtonProps) => {
  const getButtonStyle = () => {
    switch (status) {
      case 'saving':
        return 'bg-blue-400 hover:bg-blue-400';
      case 'success':
        return 'bg-green-600 hover:bg-green-700';
      case 'error':
        return 'bg-red-600 hover:bg-red-700';
      default:
        return 'bg-blue-600 hover:bg-blue-700';
    }
  };
  
  return (
    <Button 
      className={`${getButtonStyle()} text-white rounded-lg px-6 py-2 transition-all duration-200 transform hover:scale-105`}
      onClick={onClick}
      disabled={disabled || status === 'saving'}
    >
      {status === 'saving' ? (
        <><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Saving...</>
      ) : status === 'success' ? (
        <><Save className="mr-2 h-4 w-4" /> Saved!</>
      ) : status === 'error' ? (
        <><AlertTriangle className="mr-2 h-4 w-4" /> Error</>
      ) : (
        <><Save className="mr-2 h-4 w-4" /> Save Changes</>
      )}
    </Button>
  );
};

// ========================
// Component & Data - Part 2
// ========================

const BDDashboard = () => {
  // Use custom Supabase hook
  const { supabase, connectionError, setConnectionError, checkConnection, setupDatabase } = useSupabase();
  
  // ========================
  // State Management
  // ========================
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [isSaving, setIsSaving] = useState<boolean>(false);
  const [saveStatus, setSaveStatus] = useState<'idle' | 'saving' | 'success' | 'error'>('idle');
  const [tabErrors, setTabErrors] = useState<TabErrors>({});
  const [isFormModified, setIsFormModified] = useState<boolean>(false);
  
  // Tab and week selection state
  const [activeTab, setActiveTab] = useState<string>("level10");
  const [visitedTabs, setVisitedTabs] = useState<string[]>(["level10"]);
  const [selectedWeek, setSelectedWeek] = useState<string>(format(new Date(), 'yyyy-MM-dd'));
  const [weekOptions, setWeekOptions] = useState<WeekOption[]>([]);
  const [selectedDate, setSelectedDate] = useState<Date>(new Date());
  
  // Data caching
  const [cachedFormData, setCachedFormData] = useState<CachedFormData>({});
  const [currentMeetingId, setCurrentMeetingId] = useState<string | null>(null);
  const lastFetchedRef = useRef<{[key: string]: number}>({});
  
  // Level 10 meeting form data
  const [formData, setFormData] = useState<FormData>({
    attendees: '',
    safetyMessage: '',
    encoreValues: '',
    closingDeals: '',
    biddingDeals: '',
    hotProperties: '',
    terminationChanges: ''
  });

  // Vision Traction Organizer data - Updated for regions
  const [yearlyGoals, setYearlyGoals] = useState<{[key: string]: YearlyGoals}>({
    'Las Vegas': {
      id: null,
      year: new Date().getFullYear(),
      region: 'Las Vegas',
      revenueTarget: '3.25',
      revenueDescription: 'new maintenance',
      retentionGoal: '90',
      retentionDescription: 'customer retention',
      currentRevenue: '2.85',
      currentRetention: '88'
    },
    'Phoenix': {
      id: null,
      year: new Date().getFullYear(),
      region: 'Phoenix',
      revenueTarget: '2.75',
      revenueDescription: 'new maintenance',
      retentionGoal: '85',
      retentionDescription: 'customer retention',
      currentRevenue: '2.40',
      currentRetention: '82'
    }
  });

  const [issuesList, setIssuesList] = useState<Issue[]>([
    { id: null, issueText: "Create dream 100 list", isCompleted: false, assignedTo: "Sarah", dueDate: new Date() },
    { id: null, issueText: "Monthly budgets for spend", isCompleted: false, assignedTo: "Mike", dueDate: new Date() },
    { id: null, issueText: "Residential tree pruning fact sheet/social post", isCompleted: false, assignedTo: "Lisa", dueDate: new Date() },
    { id: null, issueText: "Visual aids to show internal communication", isCompleted: false, assignedTo: "John", dueDate: new Date() }
  ]);

  const [quarterlyRocks, setQuarterlyRocks] = useState<QuarterlyRocks>({
    creGroups: {
      id: null,
      title: 'CRE Groups & Committees',
      assignedTo: 'Andy & Jade',
      currentGroups: '- BOMA Executive Committee\n- NAIOP Development Committee\n- ULI Advisory Board\n- CCIM Chapter Leadership',
      actionItems: '- Schedule Q2 committee meetings\n- Submit speaker proposal for BOMA\n- Follow up on ULI mentorship program\n- Coordinate NAIOP networking event'
    },
    productionRates: {
      id: null,
      title: 'Production Rates in Aspire',
      assignedTo: 'Mike',
      currentStatus: 'Implementation Phase - 75% Complete',
      updatesNotes: '- Data migration completed for Q1\n- Team training scheduled for next week\n- New metrics dashboard in testing\n- Revenue forecasting module pending review'
    },
    events: {
      id: null,
      title: 'Q3-4 Events Planning',
      assignedTo: 'Mike',
      puttingWorldEvent: 'Date: September 15\nLocation: Putting World LV\nExpected Attendance: 75\nBudget Status: Approved\nKey Activities:\n- VIP area reserved\n- Catering quotes received\n- Save-the-dates scheduled for July 1',
      lvCharcuterieEvent: 'Date: November 8\nLocation: LV Charcuterie Downtown\nExpected Attendance: 50\nBudget Status: Pending Approval\nKey Activities:\n- Venue walk-through scheduled\n- Menu selection in progress\n- Sponsorship packages drafted'
    }
  });

  // Presentations data
  const [meetingGuidelines, setMeetingGuidelines] = useState<Guideline[]>([
    { id: null, guidelineText: "Copy of proposal. Know it like the back of your hand. Know the boundaries spot on.", category: "Meeting Preparation", sortOrder: 1 },
    { id: null, guidelineText: "List of references, notable accounts & companies we work with", category: "Meeting Preparation", sortOrder: 2 },
    { id: null, guidelineText: "Write down names of people in the meeting, refer to them by name during meeting", category: "Meeting Preparation", sortOrder: 3 }
  ]);

  const [objectionHandling, setObjectionHandling] = useState<Objection[]>([
    { id: null, objection: "Your price is higher than competitors", rebuttal: "We focus on total cost of ownership. Our solutions include comprehensive support and proven reliability that reduces long-term expenses.", thingsToSay: "Let me show you our ROI analysis\nHere's how we've saved others money\nConsider these long-term benefits", thingsNotToSay: "We're expensive because we're the best\nOthers cut corners\nYou get what you pay for" },
    { id: null, objection: "We're happy with current provider", rebuttal: "That's great to hear. Many of our current clients said the same before discovering how our innovative approaches could further improve their operations.", thingsToSay: "What do you like most about them?\nMay I share what sets us apart?\nCould we be your backup option?", thingsNotToSay: "They're outdated\nYou're missing out\nBut we're better" },
    { id: null, objection: "Not in this year's budget", rebuttal: "Understanding budget constraints is important. Let's explore how our solution could fit within your current financial framework or plan for next cycle.", thingsToSay: "When does your fiscal year start?\nLet's explore financing options\nWould phased implementation help?", thingsNotToSay: "You can't afford not to\nFind the money somewhere\nIt's not that expensive" }
  ]);

  const [quickTips, setQuickTips] = useState<QuickTip[]>([
    { id: null, category: "Opening", tipText: "Start with questions about their business challenges" },
    { id: null, category: "Presentation", tipText: "Focus on their specific needs and ROI" },
    { id: null, category: "Follow-up", tipText: "Always schedule next steps before leaving" }
  ]);

  // Memberships data
  const [memberships, setMemberships] = useState<Membership[]>([
    { id: null, salesRep: "Sarah Johnson", groups: "BOMA, NAIOP", committees: "Education Committee, Events Committee", meetingSchedule: "2nd Tuesday, 4th Thursday", meetingsAttended: 3, totalMeetings: 3, isEditing: false },
    { id: null, salesRep: "Mike Chen", groups: "ULI", committees: "Development Council", meetingSchedule: "1st Wednesday", meetingsAttended: 2, totalMeetings: 3, isEditing: false },
    { id: null, salesRep: "Lisa Brown", groups: "CCIM, CREW", committees: "Membership Committee", meetingSchedule: "3rd Monday", meetingsAttended: 3, totalMeetings: 3, isEditing: false },
    { id: null, salesRep: "John Smith", groups: "NAIOP", committees: "Government Affairs", meetingSchedule: "Last Friday", meetingsAttended: 2, totalMeetings: 3, isEditing: false }
  ]);

  // Target List data
  const [targets, setTargets] = useState<Target[]>([
    { id: "1", contact_name: "Alex Johnson", contact_title: "Property Manager", contact_email: "alex@example.com", company: "LV Business Center", properties: "Downtown Office Building, Henderson Complex", sales_rep: "SJ", sales_rep_name: "Sarah Johnson", notes: "Interested in landscape renovation for front entrance", created_at: new Date().toISOString(), projected_value: "150" },
    { id: "2", contact_name: "Maria Rodriguez", contact_title: "Facilities Director", contact_email: "maria@example.com", company: "Westside Medical Plaza", properties: "Main Hospital Campus, Satellite Clinics", sales_rep: "MC", sales_rep_name: "Mike Chen", notes: "Meeting scheduled for next month to discuss maintenance contract renewal", created_at: new Date().toISOString(), projected_value: "220" },
    { id: "3", contact_name: "Thomas Wu", contact_title: "Property Owner", contact_email: "thomas@example.com", company: "Wu Properties LLC", properties: "Retail Plaza on Charleston", sales_rep: "LB", sales_rep_name: "Lisa Brown", notes: "Looking for quotes on irrigation system upgrades", created_at: new Date().toISOString(), projected_value: "80" }
  ]);

  const [searchQuery, setSearchQuery] = useState<string>('');
  const [selectedRep, setSelectedRep] = useState<string>('');

  // ========================
  // Utility Functions
  // ========================
  
  // Generate week options for the dropdown
  useEffect(() => {
    const generateWeekOptions = () => {
      const options: WeekOption[] = [];
      const today = new Date();
      
      // Start date: Feb 24, 2025 (Monday)
      const startDate = new Date(2025, 1, 24); // Month is 0-indexed, so 1 = February
      
      // End date: Dec 31, 2025
      const endDate = new Date(2025, 11, 31);
      
      // Generate all weeks in 2025 starting from Feb 24
      let currentWeekStart = startOfWeek(startDate, { weekStartsOn: 1 });
      
      while (currentWeekStart <= endDate) {
        const weekEnd = new Date(currentWeekStart);
        weekEnd.setDate(weekEnd.getDate() + 4); // Add 4 days to get to Friday
        
        options.push({
          value: format(currentWeekStart, 'yyyy-MM-dd'),
          label: `${format(currentWeekStart, 'MMM d')} - ${format(weekEnd, 'MMM d, yyyy')}`
        });
        
        // Move to next week
        currentWeekStart = addWeeks(currentWeekStart, 1);
      }
      
      setWeekOptions(options);
      
      // Set default selected week to current week if it's in range, otherwise first week
      const todayWeekStart = startOfWeek(today, { weekStartsOn: 1 });
      if (todayWeekStart >= startDate && todayWeekStart <= endDate) {
        setSelectedWeek(format(todayWeekStart, 'yyyy-MM-dd'));
      } else {
        setSelectedWeek(format(startDate, 'yyyy-MM-dd'));
      }
    };
    
    generateWeekOptions();
  }, []);

  // Check database connection when Supabase is initialized
  useEffect(() => {
    if (supabase) {
      checkConnection();
    }
  }, [supabase, checkConnection]);

  // ========================
  // Data Fetching
  // ========================
  
  // Main fetch function that handles all data fetching based on active tab
  const fetchData = useCallback(async () => {
    if (!supabase || connectionError) return;
    
    console.log(`Fetching data for tab: ${activeTab}`);
    setIsLoading(true);
    
    try {
      if (activeTab === "level10") {
        await fetchMeetingForWeek(selectedWeek);
      } else if (activeTab === "vto") {
        // Fetch VTO data
        console.log('Fetching VTO data...');
        await fetchYearlyGoals();
        await fetchIssuesList();
        await fetchQuarterlyRocks();
      } else if (activeTab === "presentations") {
        // Fetch presentations data
        console.log('Fetching presentations data...');
        await fetchPresentationsData();
      } else if (activeTab === "memberships") {
        // Fetch memberships data
        console.log('Fetching memberships data...');
        await fetchMembershipsData();
      } else if (activeTab === "targetList") {
        // Fetch target list data
        console.log('Fetching target list data...');
        await fetchTargetsData();
      }
    } catch (error: any) {
      console.error(`Error fetching data for ${activeTab}:`, error);
      setTabErrors((prev: TabErrors) => ({
        ...prev,
        [activeTab]: {
          message: `Failed to fetch ${activeTab} data`,
          details: error
        }
      }));
    } finally {
      setIsLoading(false);
    }
  }, [activeTab, selectedWeek, supabase, connectionError]);
// Fetch Level 10 Meeting data for the selected week
  const fetchMeetingForWeek = useCallback(async (weekStartDate: string) => {
    if (!supabase) return;
    
    const lastSaveTime = window.localStorage.getItem('lastSaveTime');
    if (lastSaveTime && (new Date().getTime() - parseInt(lastSaveTime)) < 2000) {
      console.log('Skipping fetch right after save (within 2 seconds of save)');
      return;
    }
    
    const cacheKey = `level10_${weekStartDate}`;
    if (cachedFormData[cacheKey]) {
      console.log('Using cached data for', cacheKey);
      setFormData(cachedFormData[cacheKey].formData);
      setSelectedDate(cachedFormData[cacheKey].selectedDate);
      setCurrentMeetingId(cachedFormData[cacheKey].currentMeetingId);
      return;
    }
    
    try {
      console.log('Fetching meeting for week starting:', weekStartDate);
      const weekStart = new Date(weekStartDate);
      const weekEnd = new Date(weekStart);
      weekEnd.setDate(weekEnd.getDate() + 6);
      
      const { data, error } = await supabase
        .from('level10_meetings')
        .select('*')
        .gte('meeting_date', weekStart.toISOString())
        .lte('meeting_date', weekEnd.toISOString())
        .order('meeting_date', { ascending: false })
        .limit(1);
      
      if (error) {
        console.error('Error details from Supabase:', error);
        if (error.message?.includes('relation') && error.message?.includes('does not exist')) {
          console.log('Tables do not exist, returning with default data');
          return;
        }
        throw error;
      }
      
      console.log('Meeting data for week:', data);
      
      if (data && data.length > 0) {
        console.log('Setting form data from database:', data[0]);
        const newFormData: FormData = {
          attendees: data[0].attendees || '',
          safetyMessage: data[0].safety_message || '',
          encoreValues: data[0].encore_values || '',
          closingDeals: data[0].closing_deals || '',
          biddingDeals: data[0].bidding_deals || '',
          hotProperties: data[0].hot_properties || '',
          terminationChanges: data[0].termination_changes || ''
        };
        
        setFormData(newFormData);
        if (data[0].meeting_date) {
          setSelectedDate(new Date(data[0].meeting_date));
        }
        setCurrentMeetingId(data[0].id);
        
        setCachedFormData((prev: CachedFormData) => ({
          ...prev,
          [cacheKey]: {
            formData: newFormData,
            selectedDate: data[0].meeting_date ? new Date(data[0].meeting_date) : new Date(weekStartDate),
            currentMeetingId: data[0].id
          }
        }));
      } else {
        const weekDate = new Date(weekStartDate);
        const resetFormData: FormData = {
          attendees: '',
          safetyMessage: '',
          encoreValues: '',
          closingDeals: '',
          biddingDeals: '',
          hotProperties: '',
          terminationChanges: ''
        };
        
        setFormData(resetFormData);
        setSelectedDate(weekDate);
        setCurrentMeetingId(null);
        
        setCachedFormData((prev: CachedFormData) => ({
          ...prev,
          [cacheKey]: {
            formData: resetFormData,
            selectedDate: weekDate,
            currentMeetingId: null
          }
        }));
      }
      
      setIsFormModified(false);
    } catch (error: any) {
      console.error('Error in fetchMeetingForWeek:', error);
      throw error;
    }
  }, [supabase, cachedFormData]);

  // Fetch yearly goals data - Updated for regions
  const fetchYearlyGoals = async () => {
    if (!supabase) return;
    
    try {
      const { data, error } = await supabase
        .from('yearly_goals')
        .select('*')
        .eq('year', new Date().getFullYear());
        
      if (error) throw error;
      
      if (data && data.length > 0) {
        // Initialize with default values
        const newYearlyGoals: {[key: string]: YearlyGoals} = {
          'Las Vegas': {
            id: null,
            year: new Date().getFullYear(),
            region: 'Las Vegas',
            revenueTarget: '3.25',
            revenueDescription: 'new maintenance',
            retentionGoal: '90',
            retentionDescription: 'customer retention',
            currentRevenue: '2.85',
            currentRetention: '88'
          },
          'Phoenix': {
            id: null,
            year: new Date().getFullYear(),
            region: 'Phoenix',
            revenueTarget: '2.75',
            revenueDescription: 'new maintenance',
            retentionGoal: '85',
            retentionDescription: 'customer retention',
            currentRevenue: '2.40',
            currentRetention: '82'
          }
        };
        
        // Update with values from database
        data.forEach(goal => {
          const region = goal.region || 'Las Vegas'; // Default to Las Vegas if region is not specified
          
          newYearlyGoals[region] = {
            id: goal.id,
            year: goal.year,
            region: region,
            revenueTarget: (goal.revenue_target / 1000000).toFixed(2),
            revenueDescription: goal.revenue_description,
            retentionGoal: goal.retention_goal.toString(),
            retentionDescription: goal.retention_description,
            currentRevenue: goal.current_revenue ? (goal.current_revenue / 1000000).toFixed(2) : '0',
            currentRetention: goal.current_retention ? goal.current_retention.toString() : '0'
          };
        });
        
        setYearlyGoals(newYearlyGoals);
      }
    } catch (error: any) {
      console.error('Error fetching yearly goals:', error);
      setTabErrors((prev: TabErrors) => ({
        ...prev,
        vto: {
          message: 'Failed to fetch yearly goals',
          details: error
        }
      }));
    }
  };

  // Fetch issues list data
  const fetchIssuesList = async () => {
    if (!supabase) return;
    
    try {
      const { data, error } = await supabase
        .from('issues_list')
        .select('*')
        .eq('week_start_date', selectedWeek)
        .order('created_at', { ascending: true });
        
      if (error) throw error;
      
      if (data && data.length > 0) {
        const issuesData: Issue[] = data.map((issue: IssueRecord) => ({
          id: issue.id,
          issueText: issue.issue_text,
          isCompleted: issue.is_completed,
          assignedTo: issue.assigned_to || '',
          dueDate: issue.due_date ? new Date(issue.due_date) : null
        }));
        
        setIssuesList(issuesData);
      } else {
        // Keep default issues if none found
      }
    } catch (error: any) {
      console.error('Error fetching issues list:', error);
      setTabErrors((prev: TabErrors) => ({
        ...prev,
        vto: {
          message: 'Failed to fetch issues list',
          details: error
        }
      }));
    }
  };

  // Fetch quarterly rocks data
  const fetchQuarterlyRocks = async () => {
    if (!supabase) return;
    
    try {
      const { data, error } = await supabase
        .from('quarterly_rocks')
        .select('*')
        .eq('week_start_date', selectedWeek);
        
      if (error) throw error;
      
      if (data && data.length > 0) {
        // Process CRE Groups rock
        const creGroups = data.find((rock: QuarterlyRockRecord) => rock.category === 'CRE Groups');
        if (creGroups) {
          setQuarterlyRocks((prev: QuarterlyRocks) => ({
            ...prev,
            creGroups: {
              id: creGroups.id,
              title: creGroups.title || 'CRE Groups & Committees',
              assignedTo: creGroups.assigned_to || 'Andy & Jade',
              currentGroups: creGroups.current_groups || '',
              actionItems: creGroups.action_items || ''
            }
          }));
        }
        
        // Process Production rock
        const production = data.find((rock: QuarterlyRockRecord) => rock.category === 'Production');
        if (production) {
          setQuarterlyRocks((prev: QuarterlyRocks) => ({
            ...prev,
            productionRates: {
              id: production.id,
              title: production.title || 'Production Rates in Aspire',
              assignedTo: production.assigned_to || 'Mike',
              currentStatus: production.current_status || '',
              updatesNotes: production.updates_notes || ''
            }
          }));
        }
        
        // Process Events rock
        const events = data.find((rock: QuarterlyRockRecord) => rock.category === 'Events');
        if (events) {
          let puttingWorldEvent = '';
          let lvCharcuterieEvent = '';
          
          if (events.event_details) {
            try {
              const eventDetails = JSON.parse(events.event_details);
              if (Array.isArray(eventDetails) && eventDetails.length >= 2) {
                const putWorld = eventDetails[0];
                const lvChar = eventDetails[1];
                
                puttingWorldEvent = `Date: ${putWorld.date}\nLocation: ${putWorld.location}\nExpected Attendance: ${putWorld.attendance}\nBudget Status: ${putWorld.budget_status}\nKey Activities:\n${putWorld.activities.map((act: string) => `- ${act}`).join('\n')}`;
                
                lvCharcuterieEvent = `Date: ${lvChar.date}\nLocation: ${lvChar.location}\nExpected Attendance: ${lvChar.attendance}\nBudget Status: ${lvChar.budget_status}\nKey Activities:\n${lvChar.activities.map((act: string) => `- ${act}`).join('\n')}`;
              }
            } catch (e) {
              console.error('Error parsing event details JSON:', e);
            }
          }
          
          setQuarterlyRocks((prev: QuarterlyRocks) => ({
            ...prev,
            events: {
              id: events.id,
              title: events.title || 'Q3-4 Events Planning',
              assignedTo: events.assigned_to || 'Mike',
              puttingWorldEvent: puttingWorldEvent || prev.events.puttingWorldEvent,
              lvCharcuterieEvent: lvCharcuterieEvent || prev.events.lvCharcuterieEvent
            }
          }));
        }
      }
    } catch (error: any) {
      console.error('Error fetching quarterly rocks:', error);
      setTabErrors((prev: TabErrors) => ({
        ...prev,
        vto: {
          message: 'Failed to fetch quarterly rocks',
          details: error
        }
      }));
    }
  };

  // Fetch presentations data
  const fetchPresentationsData = async () => {
    if (!supabase) return;
    
    try {
      // Fetch meeting guidelines
      const { data: guidelinesData, error: guidelinesError } = await supabase
        .from('meeting_guidelines')
        .select('*')
        .order('sort_order', { ascending: true });
        
      if (guidelinesError) throw guidelinesError;
      
      if (guidelinesData && guidelinesData.length > 0) {
        setMeetingGuidelines(guidelinesData.map((g: GuidelineRecord) => ({
          id: g.id,
          guidelineText: g.guideline_text,
          category: g.category,
          sortOrder: g.sort_order
        })));
      }
      
      // Fetch objection handling
      const { data: objectionData, error: objectionError } = await supabase
        .from('objection_handling')
        .select('*');
        
      if (objectionError) throw objectionError;
      
      if (objectionData && objectionData.length > 0) {
        setObjectionHandling(objectionData.map((o: ObjectionRecord) => ({
          id: o.id,
          objection: o.objection,
          rebuttal: o.rebuttal,
          thingsToSay: o.things_to_say,
          thingsNotToSay: o.things_not_to_say,
          isEditing: false // Added isEditing property
        })));
      }
      
      // Fetch quick tips
      const { data: tipsData, error: tipsError } = await supabase
        .from('quick_tips')
        .select('*');
        
      if (tipsError) throw tipsError;
      
      if (tipsData && tipsData.length > 0) {
        setQuickTips(tipsData.map((t: QuickTipRecord) => ({
          id: t.id,
          category: t.category,
          tipText: t.tip_text
        })));
      }
    } catch (error: any) {
      console.error('Error fetching presentations data:', error);
      setTabErrors((prev: TabErrors) => ({
        ...prev,
        presentations: {
          message: 'Failed to fetch presentations data',
          details: error
        }
      }));
    }
  };

  // Fetch memberships data - UPDATED with isEditing property
  const fetchMembershipsData = async () => {
    if (!supabase) return;
    
    try {
      // Removed the filter by week_start_date since this column doesn't exist
      const { data, error } = await supabase
        .from('association_memberships')
        .select('*')
        .order('created_at', { ascending: true });
        
      if (error) throw error;
      
      if (data && data.length > 0) {
        setMemberships(data.map((m: MembershipRecord) => ({
          id: m.id,
          salesRep: m.sales_rep,
          groups: m.groups || '',
          committees: m.committees || '',
          meetingSchedule: m.meeting_schedule || '',
          meetingsAttended: m.meetings_attended || 0,
          totalMeetings: m.total_meetings || 0,
          isEditing: false // Added isEditing property
        })));
      }
    } catch (error: any) {
      console.error('Error fetching memberships data:', error);
      setTabErrors((prev: TabErrors) => ({
        ...prev,
        memberships: {
          message: 'Failed to fetch memberships data',
          details: error
        }
      }));
    }
  };

  // Fetch targets data
  const fetchTargetsData = async () => {
    if (!supabase) return;
    
    try {
      const { data, error } = await supabase
        .from('targets')
        .select('*')
        .eq('status', 'active')
        .order('created_at', { ascending: false });
        
      if (error) throw error;
      
      if (data && data.length > 0) {
        setTargets(data);
      }
    } catch (error: any) {
      console.error('Error fetching targets data:', error);
      setTabErrors((prev: TabErrors) => ({
        ...prev,
        targetList: {
          message: 'Failed to fetch targets data',
          details: error
        }
      }));
    }
  };

  // ========================
  // Event Handlers
  // ========================
  
  // Handle tab change
  const handleTabChange = (value: string) => {
    if (value !== activeTab) {
      // If leaving the VTO tab, save any changes to metrics
      if (activeTab === "vto") {
        saveYearlyGoals();
      }
      
      // Cache form data before changing tabs
      if (activeTab === "level10" && isFormModified) {
        const cacheKey = `level10_${selectedWeek}`;
        console.log('Saving form data to cache before tab change:', cacheKey, formData);
        setCachedFormData((prev: CachedFormData) => ({
          ...prev,
          [cacheKey]: {
            formData: { ...formData },
            selectedDate,
            currentMeetingId
          }
        }));
        setIsFormModified(false);
      }
      
      // Track visited tabs
      if (!visitedTabs.includes(value)) {
        setVisitedTabs((prev: string[]) => [...prev, value]);
      }
      
      setActiveTab(value);
    }
  };

  // Handle week selection change
  const handleWeekChange = (value: string) => {
    if (activeTab === "level10" && isFormModified) {
      const cacheKey = `level10_${selectedWeek}`;
      console.log('Saving form data to cache before week change:', cacheKey, formData);
      setCachedFormData((prev: CachedFormData) => ({
        ...prev,
        [cacheKey]: {
          formData: { ...formData },
          selectedDate,
          currentMeetingId
        }
      }));
      setIsFormModified(false);
    }
    
    setSelectedWeek(value);
  };

  // Handle form input changes
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFormData((prev: FormData) => ({ ...prev, [name]: value }));
    setIsFormModified(true);
  };

  // Handle yearly goals metrics update - Updated for regions
  const handleMetricsUpdate = (e?: React.FormEvent, region?: string) => {
    if (e) e.preventDefault();
    
    if (region) {
      // Update specific region
      console.log(`Updating metrics for ${region} with current state values:`, 
        yearlyGoals[region].currentRevenue, yearlyGoals[region].currentRetention);
      
      saveYearlyGoals(
        region,
        yearlyGoals[region].currentRevenue.toString().replace('M', ''),
        yearlyGoals[region].currentRetention.toString().replace('%', '')
      );
    } else {
      // Update all regions
      Object.keys(yearlyGoals).forEach(regionKey => {
        console.log(`Updating metrics for ${regionKey} with current state values:`, 
          yearlyGoals[regionKey].currentRevenue, yearlyGoals[regionKey].currentRetention);
        
        saveYearlyGoals(
          regionKey,
          yearlyGoals[regionKey].currentRevenue.toString().replace('M', ''),
          yearlyGoals[regionKey].currentRetention.toString().replace('%', '')
        );
      });
    }
  };

  // Handle current revenue input change - Updated for regions
  const handleCurrentRevenueChange = (e: React.ChangeEvent<HTMLInputElement>, region: string) => {
    const value = e.target.value.replace('M', '').trim();
    setYearlyGoals((prev) => ({
      ...prev,
      [region]: {
        ...prev[region],
        currentRevenue: value
      }
    }));
    console.log(`Current revenue for ${region} updated to:`, value);
  };

  // Handle current retention input change - Updated for regions
  const handleCurrentRetentionChange = (e: React.ChangeEvent<HTMLInputElement>, region: string) => {
    const value = e.target.value.replace('%', '').trim();
    setYearlyGoals((prev) => ({
      ...prev,
      [region]: {
        ...prev[region],
        currentRetention: value
      }
    }));
    console.log(`Current retention for ${region} updated to:`, value);
  };

  // Handle target search
  const handleTargetSearch = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchQuery(e.target.value);
  };

  // Handle sales rep filter
  const handleRepFilter = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setSelectedRep(e.target.value);
  };

  // ==============================================
  // Objection Handling Event Handlers
  // ==============================================
  
  // Toggle edit mode for an objection
  const handleObjectionEdit = (index: number) => {
    console.log('Editing objection at index:', index);
    setObjectionHandling((prev: Objection[]) => 
      prev.map((obj: Objection, i: number) => 
        i === index ? { ...obj, isEditing: true } : obj
      )
    );
  };

  // Update an objection field while editing
  const handleObjectionChange = (index: number, field: keyof Objection, value: string) => {
    setObjectionHandling((prev: Objection[]) => 
      prev.map((obj: Objection, i: number) => 
        i === index ? { ...obj, [field]: value } : obj
      )
    );
  };

  // Save an objection to state and Supabase
  const handleObjectionSave = async (objection: Objection, isNew = false) => {
    if (!supabase) {
      console.error('Cannot save objection - Supabase not initialized');
      return;
    }

    setSaveStatus('saving');
    
    try {
      const objectionData = {
        objection: objection.objection,
        rebuttal: objection.rebuttal,
        things_to_say: objection.thingsToSay,
        things_not_to_say: objection.thingsNotToSay,
        updated_at: new Date().toISOString()
      };
      
      // Define explicit type for the result variable and initialize as null
      let result: { data: any[] | null; error: any } | null = null;
      
      // If this is a new objection (no valid database ID)
      if (isNew || !objection.id || objection.id.toString().startsWith('temp-')) {
        console.log('Inserting new objection:', objectionData);
        result = await supabase
          .from('objection_handling')
          .insert(objectionData)
          .select();
          
        if (result && result.error) throw result.error;
        
        if (result && result.data && result.data.length > 0) {
          // Replace the temporary objection with the one that has a real ID from the database
          setObjectionHandling((prev: Objection[]) => 
            prev.map((obj: Objection) => 
              (obj.id === objection.id) ? 
              { 
                id: result!.data![0].id, 
                objection: result!.data![0].objection,
                rebuttal: result!.data![0].rebuttal,
                thingsToSay: result!.data![0].things_to_say,
                thingsNotToSay: result!.data![0].things_not_to_say,
                isEditing: false 
              } : obj
            )
          );
        }
      } else {
        // This is an existing objection
        console.log('Updating existing objection with ID:', objection.id);
        result = await supabase
          .from('objection_handling')
          .update(objectionData)
          .eq('id', objection.id)
          .select();
          
        if (result && result.error) throw result.error;
        
        // Turn off edit mode
        setObjectionHandling((prev: Objection[]) => 
          prev.map((obj: Objection) => 
            obj.id === objection.id ? { ...obj, isEditing: false } : obj
          )
        );
      }
      
      setSaveStatus('success');
      setTimeout(() => setSaveStatus('idle'), 1500);
      
    } catch (error: any) {
      console.error('Error saving objection:', error);
      setSaveStatus('error');
      setTabErrors((prev: TabErrors) => ({
        ...prev,
        presentations: {
          message: 'Failed to save objection',
          details: error
        }
      }));
      setTimeout(() => setSaveStatus('idle'), 1500);
    }
  };

  // Delete an objection from state and Supabase
  const handleObjectionDelete = async (index: number) => {
    if (!supabase) {
      console.error('Cannot delete objection - Supabase not initialized');
      return;
    }
    
    const objection = objectionHandling[index];
    
    setSaveStatus('saving');
    
    try {
      // If the objection has a valid database ID (not a temporary one)
      if (objection.id && !objection.id.toString().startsWith('temp-')) {
        console.log('Deleting objection with ID:', objection.id);
        const { error } = await supabase
          .from('objection_handling')
          .delete()
          .eq('id', objection.id);
          
        if (error) throw error;
      }
      
      // Remove from state regardless of whether it was in the database
      setObjectionHandling((prev: Objection[]) => prev.filter((_, i: number) => i !== index));
      
      setSaveStatus('success');
      setTimeout(() => setSaveStatus('idle'), 1500);
      
    } catch (error: any) {
      console.error('Error deleting objection:', error);
      setSaveStatus('error');
      setTabErrors((prev: TabErrors) => ({
        ...prev,
        presentations: {
          message: 'Failed to delete objection',
          details: error
        }
      }));
      setTimeout(() => setSaveStatus('idle'), 1500);
    }
  };
  
  // ==============================================
  // Membership Event Handlers (New)
  // ==============================================
  
  // Toggle edit mode for a membership
  const handleMembershipEdit = (index: number) => {
    console.log('Editing membership at index:', index);
    setMemberships((prev: Membership[]) => 
      prev.map((mem: Membership, i: number) => 
        i === index ? { ...mem, isEditing: true } : mem
      )
    );
  };

  // Update a membership field while editing
  const handleMembershipChange = (index: number, field: keyof Membership, value: string | number) => {
    setMemberships((prev: Membership[]) => 
      prev.map((mem: Membership, i: number) => 
        i === index ? { ...mem, [field]: value } : mem
      )
    );
  };

  // Save a membership to state and Supabase
  const handleMembershipSave = async (membership: Membership, isNew = false) => {
    if (!supabase) {
      console.error('Cannot save membership - Supabase not initialized');
      return;
    }

    setSaveStatus('saving');
    
    try {
      const membershipData = {
        sales_rep: membership.salesRep,
        groups: membership.groups,
        committees: membership.committees,
        meeting_schedule: membership.meetingSchedule,
        meetings_attended: membership.meetingsAttended,
        total_meetings: membership.totalMeetings,
        updated_at: new Date().toISOString()
      };
      
      // Define explicit type for the result variable and initialize as null
      let result: { data: any[] | null; error: any } | null = null;
      
      // If this is a new membership (no valid database ID)
      if (isNew || !membership.id || membership.id.toString().startsWith('temp-')) {
        console.log('Inserting new membership:', membershipData);
        result = await supabase
          .from('association_memberships')
          .insert(membershipData)
          .select();
          
        if (result && result.error) throw result.error;
        
        if (result && result.data && result.data.length > 0) {
          // Replace the temporary membership with the one that has a real ID from the database
          setMemberships((prev: Membership[]) => 
            prev.map((mem: Membership) => 
              (mem.id === membership.id) ? 
              { 
                id: result!.data![0].id, 
                salesRep: result!.data![0].sales_rep,
                groups: result!.data![0].groups || '',
                committees: result!.data![0].committees || '',
                meetingSchedule: result!.data![0].meeting_schedule || '',
                meetingsAttended: result!.data![0].meetings_attended || 0,
                totalMeetings: result!.data![0].total_meetings || 0,
                isEditing: false 
              } : mem
            )
          );
        }
      } else {
        // This is an existing membership
        console.log('Updating existing membership with ID:', membership.id);
        result = await supabase
          .from('association_memberships')
          .update(membershipData)
          .eq('id', membership.id)
          .select();
          
        if (result && result.error) throw result.error;
        
        // Turn off edit mode
        setMemberships((prev: Membership[]) => 
          prev.map((mem: Membership) => 
            mem.id === membership.id ? { ...mem, isEditing: false } : mem
          )
        );
      }
      
      setSaveStatus('success');
      setTimeout(() => setSaveStatus('idle'), 1500);
      
    } catch (error: any) {
      console.error('Error saving membership:', error);
      setSaveStatus('error');
      setTabErrors((prev: TabErrors) => ({
        ...prev,
        memberships: {
          message: 'Failed to save membership',
          details: error
        }
      }));
      setTimeout(() => setSaveStatus('idle'), 1500);
    }
  };

  // Delete a membership from state and Supabase
  const handleMembershipDelete = async (index: number) => {
    if (!supabase) {
      console.error('Cannot delete membership - Supabase not initialized');
      return;
    }
    
    const membership = memberships[index];
    
    setSaveStatus('saving');
    
    try {
      // If the membership has a valid database ID (not a temporary one)
      if (membership.id && !membership.id.toString().startsWith('temp-')) {
        console.log('Deleting membership with ID:', membership.id);
        const { error } = await supabase
          .from('association_memberships')
          .delete()
          .eq('id', membership.id);
          
        if (error) throw error;
      }
      
      // Remove from state regardless of whether it was in the database
      setMemberships((prev: Membership[]) => prev.filter((_, i: number) => i !== index));
      
      setSaveStatus('success');
      setTimeout(() => setSaveStatus('idle'), 1500);
      
    } catch (error: any) {
      console.error('Error deleting membership:', error);
      setSaveStatus('error');
      setTabErrors((prev: TabErrors) => ({
        ...prev,
        memberships: {
          message: 'Failed to delete membership',
          details: error
        }
      }));
      setTimeout(() => setSaveStatus('idle'), 1500);
    }
  };

  // ========================
  // Save Functions
  // ========================
  
  // Main save function
  const saveData = async () => {
    if (!supabase) {
      setConnectionError('Supabase client is not initialized. Cannot save data.');
      return;
    }
    
    setIsSaving(true);
    setSaveStatus('saving');
    
    try {
      console.log(`Saving data for ${activeTab} tab for week: ${selectedWeek}`);
      
      if (activeTab === "level10") {
        // Save Level 10 meeting data
        const meetingData = {
          meeting_date: selectedDate?.toISOString(),
          week_start_date: selectedWeek,
          attendees: formData.attendees,
          safety_message: formData.safetyMessage,
          encore_values: formData.encoreValues,
          closing_deals: formData.closingDeals,
          bidding_deals: formData.biddingDeals,
          hot_properties: formData.hotProperties || '',
          termination_changes: formData.terminationChanges || '',
          updated_at: new Date().toISOString()
        };
        
        console.log('Saving Level 10 meeting data:', meetingData);
        // Define explicit type for the result variable and initialize as null
        let result: { data: any[] | null; error: any } | null = null;
        
        if (currentMeetingId) {
          console.log('Updating existing meeting with ID:', currentMeetingId);
          result = await supabase
            .from('level10_meetings')
            .update(meetingData)
            .eq('id', currentMeetingId)
            .select();
        } else {
          console.log('Creating new meeting for week:', selectedWeek);
          result = await supabase
            .from('level10_meetings')
            .insert(meetingData)
            .select();
        }
        
        if (!result) {
          throw new Error('No result received from database operation');
        }
        
        const { data, error } = result;
        if (error) {
          console.error('Error saving Level 10 meeting to Supabase:', error);
          throw error;
        }
        
        console.log('Level 10 meeting save successful, response:', data);
        if (data && data.length > 0) {
          console.log('Save successful - using current form values to prevent mismatch');
          setCurrentMeetingId(data[0].id);
          const saveTime = new Date().getTime();
          window.localStorage.setItem('lastSaveTime', saveTime.toString());
          
          const cacheKey = `level10_${selectedWeek}`;
          setCachedFormData((prev: CachedFormData) => ({
            ...prev,
            [cacheKey]: {
              formData: { ...formData },
              selectedDate,
              currentMeetingId: data[0].id
            }
          }));
          
          setIsFormModified(false);
        }
      } else if (activeTab === "vto") {
        try {
          // Save yearly goals for all regions
          for (const regionKey of Object.keys(yearlyGoals)) {
            const region = yearlyGoals[regionKey];
            
            const yearlyGoalsData = {
              year: region.year,
              region: region.region,
              revenue_target: parseFloat(region.revenueTarget) * 1000000,
              revenue_description: region.revenueDescription,
              retention_goal: parseFloat(region.retentionGoal),
              retention_description: region.retentionDescription,
              current_revenue: parseFloat(region.currentRevenue) * 1000000,
              current_retention: parseFloat(region.currentRetention),
              updated_at: new Date().toISOString()
            };
            
            console.log(`Saving yearly goals data for ${region.region}:`, yearlyGoalsData);
            let yearlyGoalsResult;
            
            if (region.id) {
              yearlyGoalsResult = await supabase
                .from('yearly_goals')
                .update(yearlyGoalsData)
                .eq('id', region.id)
                .select();
            } else {
              yearlyGoalsResult = await supabase
                .from('yearly_goals')
                .insert(yearlyGoalsData)
                .select();
            }
            
            if (yearlyGoalsResult.error) {
              console.error(`Error saving yearly goals for ${region.region}:`, yearlyGoalsResult.error);
              throw yearlyGoalsResult.error;
            }
            
            if (yearlyGoalsResult.data && yearlyGoalsResult.data.length > 0) {
              setYearlyGoals((prev) => ({
                ...prev,
                [region.region]: { 
                  ...prev[region.region], 
                  id: yearlyGoalsResult.data[0].id 
                }
              }));
            }
          }
          
          // Save issues list
          console.log('Saving issues list data:', issuesList);
          for (const issue of issuesList) {
            const issueData = {
              issue_text: issue.issueText,
              is_completed: issue.isCompleted,
              assigned_to: issue.assignedTo,
              due_date: issue.dueDate?.toISOString().split('T')[0],
              week_start_date: selectedWeek,
              updated_at: new Date().toISOString()
            };
            
            if (issue.id) {
              const { error } = await supabase
                .from('issues_list')
                .update(issueData)
                .eq('id', issue.id);
                
              if (error) {
                console.error('Error updating issue:', error);
                throw error;
              }
            } else {
              const { data, error } = await supabase
                .from('issues_list')
                .insert(issueData)
                .select();
                
              if (error) {
                console.error('Error inserting issue:', error);
                throw error;
              }
              
              if (data && data.length > 0) {
                setIssuesList((prev: Issue[]) => 
                  prev.map((i: Issue) => 
                    i.issueText === issue.issueText && i.id === null
                      ? { ...i, id: data[0].id }
                      : i
                  )
                );
              }
            }
          }
          
          // Save CRE Groups rock
          const creGroupsData = {
            title: quarterlyRocks.creGroups.title,  // Now editable
            category: 'CRE Groups',
            assigned_to: quarterlyRocks.creGroups.assignedTo,  // Now editable
            current_groups: quarterlyRocks.creGroups.currentGroups,
            action_items: quarterlyRocks.creGroups.actionItems,
            week_start_date: selectedWeek,
            updated_at: new Date().toISOString()
          };
          
          console.log('Saving CRE Groups data:', creGroupsData);
          if (quarterlyRocks.creGroups.id) {
            const { error } = await supabase
              .from('quarterly_rocks')
              .update(creGroupsData)
              .eq('id', quarterlyRocks.creGroups.id);
              
            if (error) {
              console.error('Error updating CRE Groups:', error);
              throw error;
            }
          } else {
            const { data, error } = await supabase
              .from('quarterly_rocks')
              .insert(creGroupsData)
              .select();
              
            if (error) {
              console.error('Error inserting CRE Groups:', error);
              throw error;
            }
            
            if (data && data.length > 0) {
              setQuarterlyRocks((prev: QuarterlyRocks) => ({
                ...prev,
                creGroups: { ...prev.creGroups, id: data[0].id }
              }));
            }
          }
          
          // Save Production Rates rock
          const productionRatesData = {
            title: quarterlyRocks.productionRates.title,  // Now editable
            category: 'Production',
            assigned_to: quarterlyRocks.productionRates.assignedTo,  // Now editable
            current_status: quarterlyRocks.productionRates.currentStatus,
            updates_notes: quarterlyRocks.productionRates.updatesNotes,
            week_start_date: selectedWeek,
            updated_at: new Date().toISOString()
          };
          
          console.log('Saving Production Rates data:', productionRatesData);
          if (quarterlyRocks.productionRates.id) {
            const { error } = await supabase
              .from('quarterly_rocks')
              .update(productionRatesData)
              .eq('id', quarterlyRocks.productionRates.id);
              
            if (error) {
              console.error('Error updating Production Rates:', error);
              throw error;
            }
          } else {
            const { data, error } = await supabase
              .from('quarterly_rocks')
              .insert(productionRatesData)
              .select();
              
            if (error) {
              console.error('Error inserting Production Rates:', error);
              throw error;
            }
            
            if (data && data.length > 0) {
              setQuarterlyRocks((prev: QuarterlyRocks) => ({
                ...prev,
                productionRates: { ...prev.productionRates, id: data[0].id }
              }));
            }
          }
          
          // Parse Events data from text areas
          const puttingWorld: {
            name: string;
            date: string;
            location: string;
            attendance: number;
            budget_status: string;
            activities: string[];
          } = { 
            name: "Putting World Event", 
            date: "", 
            location: "", 
            attendance: 0, 
            budget_status: "", 
            activities: [] 
          };
          
          const lvCharcuterie: {
            name: string;
            date: string;
            location: string;
            attendance: number;
            budget_status: string;
            activities: string[];
          } = { 
            name: "LV Charcuterie Event", 
            date: "", 
            location: "", 
            attendance: 0, 
            budget_status: "", 
            activities: [] 
          };
          
          const puttingWorldLines = quarterlyRocks.events.puttingWorldEvent.split('\n');
          puttingWorldLines.forEach((line: string) => {
            if (line.startsWith('Date:')) puttingWorld.date = line.replace('Date:', '').trim();
            else if (line.startsWith('Location:')) puttingWorld.location = line.replace('Location:', '').trim();
            else if (line.startsWith('Expected Attendance:')) puttingWorld.attendance = parseInt(line.replace('Expected Attendance:', '').trim()) || 0;
            else if (line.startsWith('Budget Status:')) puttingWorld.budget_status = line.replace('Budget Status:', '').trim();
            else if (line.startsWith('- ')) puttingWorld.activities.push(line.replace('- ', '').trim());
          });
          
          const lvCharcuterieLines = quarterlyRocks.events.lvCharcuterieEvent.split('\n');
          lvCharcuterieLines.forEach((line: string) => {
            if (line.startsWith('Date:')) lvCharcuterie.date = line.replace('Date:', '').trim();
            else if (line.startsWith('Location:')) lvCharcuterie.location = line.replace('Location:', '').trim();
            else if (line.startsWith('Expected Attendance:')) lvCharcuterie.attendance = parseInt(line.replace('Expected Attendance:', '').trim()) || 0;
            else if (line.startsWith('Budget Status:')) lvCharcuterie.budget_status = line.replace('Budget Status:', '').trim();
            else if (line.startsWith('- ')) lvCharcuterie.activities.push(line.replace('- ', '').trim());
          });
          
          // Save Events rock
          const eventsData = {
            title: quarterlyRocks.events.title,  // Now editable
            category: 'Events',
            assigned_to: quarterlyRocks.events.assignedTo,  // Now editable
            event_details: JSON.stringify([puttingWorld, lvCharcuterie]),
            week_start_date: selectedWeek,
            updated_at: new Date().toISOString()
          };
          
          console.log('Saving Events data:', eventsData);
          if (quarterlyRocks.events.id) {
            const { error } = await supabase
              .from('quarterly_rocks')
              .update(eventsData)
              .eq('id', quarterlyRocks.events.id);
              
            if (error) {
              console.error('Error updating Events:', error);
              throw error;
            }
          } else {
            const { data, error } = await supabase
              .from('quarterly_rocks')
              .insert(eventsData)
              .select();
              
            if (error) {
              console.error('Error inserting Events:', error);
              throw error;
            }
            
            if (data && data.length > 0) {
              setQuarterlyRocks((prev: QuarterlyRocks) => ({
                ...prev,
                events: { ...prev.events, id: data[0].id }
              }));
            }
          }
        } catch (vtoError: any) {
          console.error('Error saving VTO data:', vtoError);
          throw vtoError;
        }
      } else if (activeTab === "presentations") {
        // Presentations tab save logic here (omitted for brevity)
      } else if (activeTab === "memberships") {
        // Memberships tab save logic here (omitted for brevity)
      } else if (activeTab === "targetList") {
        // Target list tab save logic here (omitted for brevity)
      }
      
      console.log(`Successfully saved ${activeTab} data`);
      setSaveStatus('success');
      setTimeout(() => setSaveStatus('idle'), 3000);
    } catch (error: any) {
      console.error('Error saving data:', error);
      
      // Extract more detailed error information
      let errorDetails = '';
      if (error) {
        if (error.message) {
          errorDetails = error.message;
        } else if (error.details) {
          errorDetails = typeof error.details === 'string' ? error.details : JSON.stringify(error.details);
        } else if (error.code) {
          errorDetails = `Error code: ${error.code}`;
        } else if (typeof error === 'object') {
          errorDetails = JSON.stringify(error);
        } else {
          errorDetails = String(error);
        }
      }
      
      // If we've got an empty object as a string, provide more context
      if (errorDetails === '{}') {
        errorDetails = 'Empty error object returned from Supabase. Check your database permissions and schema.';
      }
      
      setSaveStatus('error');
      setTabErrors((prev: TabErrors) => ({
        ...prev,
        [activeTab]: {
          message: `Failed to save ${activeTab} data: ${errorDetails}`,
          details: error
        }
      }));
      setTimeout(() => setSaveStatus('idle'), 3000);
    } finally {
      setIsSaving(false);
    }
  };

  // Save yearly goals separately - Updated for regions
  const saveYearlyGoals = async (region?: string, currentRevenueStr?: string, currentRetentionStr?: string) => {
    if (!supabase) return;
    
    setSaveStatus('saving');
    
    try {
      if (region) {
        // Save for specific region
        // Use parameters if provided, otherwise use state values
        const revenueToSave = currentRevenueStr || yearlyGoals[region].currentRevenue;
        const retentionToSave = currentRetentionStr || yearlyGoals[region].currentRetention;
        console.log(`Saving yearly goals for ${region} with metrics:`, revenueToSave, retentionToSave);
        
        const yearlyGoalsData = {
          year: yearlyGoals[region].year,
          region: region,
          revenue_target: parseFloat(yearlyGoals[region].revenueTarget) * 1000000,
          revenue_description: yearlyGoals[region].revenueDescription,
          retention_goal: parseFloat(yearlyGoals[region].retentionGoal),
          retention_description: yearlyGoals[region].retentionDescription,
          current_revenue: parseFloat(revenueToSave) * 1000000,
          current_retention: parseFloat(retentionToSave),
          updated_at: new Date().toISOString()
        };
        
        console.log(`Saving yearly goals data for ${region}:`, yearlyGoalsData);
        // Define explicit type for the result variable and initialize as null
        let result: { data: any[] | null; error: any } | null = null;
        
        if (yearlyGoals[region].id) {
          console.log(`Updating existing yearly goals for ${region} with ID:`, yearlyGoals[region].id);
          result = await supabase
            .from('yearly_goals')
            .update(yearlyGoalsData)
            .eq('id', yearlyGoals[region].id)
            .select();
        } else {
          console.log(`Creating new yearly goals entry for ${region}`);
          result = await supabase
            .from('yearly_goals')
            .insert(yearlyGoalsData)
            .select();
        }
        
        if (result && result.error) {
          console.error(`Error saving yearly goals for ${region}:`, result.error);
          throw result.error;
        }
        
        console.log(`Yearly goals save successful for ${region}, response:`, result?.data);
        if (result && result.data && result.data.length > 0) {
          console.log(`Updating state with new yearly goals ID for ${region}`);
          setYearlyGoals((prev) => ({
            ...prev,
            [region]: {
              ...prev[region],
              id: result!.data![0].id,
              currentRevenue: revenueToSave,
              currentRetention: retentionToSave
            }
          }));
        }
      } else {
        // Save for all regions if no specific region provided
        for (const regionKey of Object.keys(yearlyGoals)) {
          await saveYearlyGoals(
            regionKey, 
            yearlyGoals[regionKey].currentRevenue, 
            yearlyGoals[regionKey].currentRetention
          );
        }
      }
      
      setSaveStatus('success');
      setTimeout(() => setSaveStatus('idle'), 1500);
    } catch (error: any) {
      console.error('Error saving yearly goals:', error);
      setSaveStatus('error');
      setTabErrors((prev: TabErrors) => ({
        ...prev,
        vto: {
          message: 'Failed to save yearly goals',
          details: error
        }
      }));
      setTimeout(() => setSaveStatus('idle'), 1500);
    }
  };

  // Save target (for immediate updates to the targets list)
  const saveTarget = async (updateFn: (targets: Target[]) => Target[]) => {
    try {
      // Function code omitted for brevity
    } catch (error: any) {
      // Error handling omitted for brevity
    }
  };
  
  // ========================
  // Effects
  // ========================
  
  // Fetch data when tab or week changes
  useEffect(() => {
    if (connectionError) return;
    
    if (activeTab === "level10") {
      const cacheKey = `level10_${selectedWeek}`;
      const cachedData = cachedFormData[cacheKey];
      
      if (cachedData) {
        console.log('Loading from cache:', cacheKey);
        setFormData(cachedData.formData);
        setSelectedDate(cachedData.selectedDate);
        setCurrentMeetingId(cachedData.currentMeetingId);
        setIsFormModified(false);
      } else {
        console.log('No cache found, fetching from database');
        fetchMeetingForWeek(selectedWeek);
      }
    } else {
      fetchData();
    }
  }, [activeTab, selectedWeek, connectionError, fetchData, fetchMeetingForWeek, cachedFormData]);

  // Filter targets based on search and rep selection
  const filteredTargets = targets.filter((target: Target) => {
    const matchesSearch = searchQuery === '' || 
      target.contact_name?.toLowerCase().includes(searchQuery.toLowerCase()) ||
      target.company?.toLowerCase().includes(searchQuery.toLowerCase()) ||
      target.properties?.toLowerCase().includes(searchQuery.toLowerCase()) ||
      target.notes?.toLowerCase().includes(searchQuery.toLowerCase());
      
    const matchesRep = selectedRep === '' || target.sales_rep === selectedRep;
    
    return matchesSearch && matchesRep;
  });